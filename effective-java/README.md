## 考虑使用静态工厂方法替代构造方法

Q：静态工厂方法的优点？

它们有名字。

可以使用它们来控制实例的数量（例如：boolean.valueOf）。

可以返回返回类的子类型。



## 当构造方法参数过多时使用 builder 模式

Q：构建器的优点？

当你的构造函数可能需要很多参数时，builder 模式更易于阅读和书写。

类可以是不可变的（而不是使用 java bean）。

可以防止对象状态不一致。



## 依赖注入优于硬连接资源

Q：为什么将 SpellChecker 实现为静态工具类或单例，在需要支持多种字典的场景下是不灵活的？

因为这两种方式都将依赖 Lexicon dictionary 硬编码在了类的内部。静态工具类依赖在类加载时就确定了，无法更改。单例模式依赖是实例字段，但也是在单例实例创建时就固定了。硬编码意味着无法切换依赖和违反单一职责。

Q：依赖注入是如何解决这个灵活性问题的？请描述它的工作机制。

SpellChecker 类内部不再使用 new 来创建 Lexicon 实例。将 Lexicon dictionary 作为类的字段，并通过构造器参数要求外部传入。由 SpellChecker 的调用者来决定传入哪个具体的 Lexicon 实现。例如：Lexicon englishDictionary = new EnglishLexicon() 用于生产，

Lexicon testDictionary = new MockDictionaryForTesting() 用于测试。

Q：在 SpellChecker 的依赖注入版本中，为什么将 dictionary 字段声明为 final 是有益的？

它表明了 SpellChecker 实例在其整个生命周期内都只使用同一本字典，初始化完毕这个字段的引用就不可变了。这意味着该对象可以在多线程环境下安全地共享，而不需要额外的同步开销。



## 在公共类中使用访问方法而不是公共属性

Q：一个类把属性 public 暴露出去，和把属性 private 并提供 getter/setter ，最大的区别是什么？

public 属性 → 直接改或读，不受控制。private + getter/setter → 外部只能通过方法访问，类本身可以在方法里添加逻辑。

Q：为什么公共类最好不要暴露属性 ？

保持外部 API 稳定，不受内部实现强制绑定。

Q：回答哪些情况下可以暴露属性，哪些情况下使用 getter/setter ?

如果一个类在其包之外是可访问的，则提供访问方法来保留更改类内部表示的灵活性。但是，如果一个类是包级私有的，或者是一个私有的内部类，那么暴露它的数据属性就没有什么本质上的错误。



## 使类和成员的可访问性最小化

Q：一个只在本包内被使用的工具类，为什么应该声明为包级私有（package-private）?

只在包内用的顶层类，不需要暴露给外部。

Q：请问 public static final String[ ] values 存在哪个设计上的风险，选择何种改进方案？

可变性风险。final 关键字并不能保证数组内部的元素不被修改，使用不可变列表 Collections.unmodifiableList( ) 。



## 组合优于继承

Q：为什么 InstrumentedHashSet 的 addAll 调用会让 addCount 变成 6 而不是 3 ？

InstrumentedHashSet 希望通过重写 add 和 addAll 来正确计数，但没有考虑到 HashSet 的 addAll 实现会调用 add ，导致计数被重复计算。

Q：ColoredCircle 在 Circle 基础上，加上了颜色属性，CountingList 能统计加入过多少元素，不管后来有没有被删除。请分析这两种情况分别应该用继承还是组合？

ColoredCircle 是 Circle 的一种，增加颜色属性是一个简单扩展，继承可以直接复用 Circle 的行为，符合继承关系。 CountingList 是Circle 的一个附加功能，组合提供更好的控制和灵活性，避免了继承的脆弱性。

Q：ForwardingList 把所有方法转发给内部的 List 实例，什么时候用转发包装类？

需要包装一个实现，增强或改变其部分行为，它可以避免继承带来的实现依赖问题。



## 接口优于抽象类

Q：接口优于抽象类的核心是什么？

接口 （interface）提供了更高的灵活性和可扩展性。它支持多重继承（实现多个接口），能够让不同的类共享相同的行为，而抽象类则往往使得类之间的关系变得紧密，导致灵活性降低接口还支持默认方法，子类都可以直接使用这个方法，而不需要重新实现。



## 类层次结构优于标签类

Q：为什么类层次结构优于标签类？

减少条件判断，更易扩展维护，类层次结构可以通过继承父类共享行为，不同的子类可以有特定的行为。通过类层次结构，Shape 类定义了通用的接口，Circle 和 Rectangle类分别实现了自己的 area() 方法，避免了在Shape 类中使用条件判断来处理不同类型的形状。



## 使用枚举类型替代整型常量

Q：int 常量的问题？

没有类型安全（Apple 和 Orange 混用也不会报错）。

没有命名空间（只能靠前缀区分）。

修改值会导致客户端代码出 bug（因为编译时常量会被硬编码进去）。

打印时没有可读性，只能看到数字。

不能方便地遍历所有值。

Q：枚举的优势？

枚举是类，本质上就是一组受控的单例对象。

类型安全（参数必须是声明过的枚举常量）。

自带命名空间（Apple.FUJI 不会和 Orange.NAVEL 冲突）。

可以携带数据和方法（比如 Planet 里存质量和半径）。

可以有常量特定的方法实现（每个枚举常量有自己的逻辑）。

可以和策略模式结合使用（像 PayrollDay 的例子）。

Q：什么时候用 switch，什么时候用多态？

如果你能修改枚举类型 → 用抽象方法 + 常量特定实现（更安全）。

如果你不能修改枚举类型（比如它来自第三方库） → 可以在自己代码里用 switch 补充缺失的方法。



**检查参数有效性**

Q：为什么要检查参数？

在方法入口就抛异常，异常信息更清晰可读，能保证方法内部逻辑只处理合法的情况，更安全。

Q：如果没有在构造方法里检查参数，而是等以后调用某个方法时才抛异常，会出现什么坏处？

会生成错误对象。



## 必要时进行防御性拷贝

Q：为什么 end.setYear( ) 可以改掉 Period 的内部状态？

在 Java 里，this.end = end; 并不会产生一个新的 Date 对象，只是把 引用 复制过去。所以 Period 里面和外面，其实指向的是 同一个 Date 对象。用防御性拷贝，在构造函数里创建一个新的对象，存进去。

Q：写一个 Student 不可变类，要求名字和成绩一旦创建就不能改动，如何实现？

构造方法防御性拷贝，这样即使调用者后面改了 scores 原始列表，你的 Student 里的数据也不会受影响；访问器返回不可修改视图，这样调用者拿到的 List 不能增删改，如果要允许修改，可以提供安全的方法。



**最小化局部变量的作用域**

Q：为什么在第一次使用的地方声明变量，会比在一开始就声明所有变量更好？

推迟变量声明的好处是作用域小，减少出错机会，也让读代码的人负担更轻。但是也有例外情况，在 try-catch 场景下，如果因为异常处理或者逻辑需要，变量必须在 try 外继续使用，就要提前声明。



**只针对异常的情况下才使用异常**

Q：使用 Iterator 遍历集合的异常循环可能带来什么问题？

正常流程里 catch 了异常，本来应该暴露出来的错误（比如调用了不该调用的方法、访问了不存在的元素）会被误以为是正常结束，调试时就少了堆栈轨迹这个线索。抛出和捕获异常的成本远高于一次简单的条件判断，而且 JVM 不会对这种“滥用异常”做性能优化。



**同步访问共享的可变数据**

Q：在 private static boolean stopRequested = false 中加入 volatile 的作用？

保证可见性，主线程写入 true 会立即刷新到主内存。后台线程每次读取都会直接从主内存取得最新的值。volatile 可以修改，但它不保证复合操作的原子性。要保证这种复合操作的正确性，就需要 synchronized 锁或者 AtomicInteger/AtomicLong 等原子类。



**executor 、task 和 stream 优先于线程**

Q：为什么在高负载的服务器中不建议使用 newCachedThreadPool ？

在 newCachedThreadPool 中：任务不会排队，而是直接分配给可用线程执行。如果没有空闲线程，就会立即新建线程。在高负载场景下，任务量激增 → 线程数激增 → CPU 上下文切换频繁（性能下降）→ 内存占用暴涨（可能导致 OOM）。所以，高负载下更适合用 newFixedThreadPool（限制线程数量，避免失控）。



## 优先选择 Java 序列化的替代方案

Q：你如何理解Java序列化？

Java 序列化是通过 Serializable 接口和 ObjectInputStream/ObjectOutputStream 来实现对象与字节流之间的转换的。

Q：Java 反序列化的风险来自哪里？

Java 反序列化最大的风险点之一是 readObject() 方法的行为。readObject() 不像普通构造函数那样只创建某个类的实例，它能实例化类路径上几乎任何实现了 Serializable 的类。在反序列化过程中，它会触发类中的方法（包括危险的逻辑），哪怕这个类本身没漏洞，也可能被攻击链利用。这种风险还来自JDK 自带的类、第三方库的类，甚至RMI、JMX、JMS 这些 Java 自带的通信机制。

Q：反序列化炸弹攻击是怎么让服务器瘫痪的？

反序列化炸弹攻击的原理是用一个很小的字节流（比如 5KB 多）构造一个对象图，让反序列化过程陷入指数级的计算。反序列化某些集合（如 HashSet）时，会调用元素的hashCode() ，如果对象图设计得层层嵌套，就会触发大量递归调用。